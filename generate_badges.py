"""Generate identification badges from an SVG template.

The script reads the CSV export produced by the forum-métier form and
creates an individual badge for each participant. Badges are generated by
duplicating the SVG template found in ``static/ressources/badge_template.svg``
and replacing the text nodes identified by their ``id`` attributes.

Example usage::

    python generate_badges.py dump.csv static/ressources/badge_template.svg \
        --output badges --formats svg

If ``cairosvg`` is installed you can also request PDF or PNG exports by
passing ``--formats svg pdf`` (or ``png``).
"""

from __future__ import annotations

import argparse
import csv
import re
import sys
from copy import deepcopy
from dataclasses import dataclass
from io import BytesIO
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping, Sequence

import xml.etree.ElementTree as ET


# SVG documents use this namespace. Registering it ensures that ElementTree
# keeps the prefix-less ``svg`` namespace when we write the generated files.
ET.register_namespace("", "http://www.w3.org/2000/svg")


@dataclass
class Participant:
    """Data structure holding the information required to build a badge."""

    company: str
    last_name: str
    first_name: str
    role: str
    email: str

    @property
    def full_name(self) -> str:
        """Return the full name formatted for display on the badge."""

        names = [self.first_name.strip(), self.last_name.strip()]
        return " ".join(part for part in names if part)

    def as_mapping(self) -> Dict[str, str]:
        """Return a mapping used to update the SVG template."""

        return {
            "company": self.company.strip() or "Entreprise",
            "full_name": self.full_name or "Participant",
            "role": self.role.strip() or "Poste",  # fallback text
            "email": self.email.strip(),
        }


def _to_text(value: Any) -> str:
    """Safely convert database/CSV values to strings."""

    if value is None:
        return ""
    return str(value)


def extract_participants(rows: Iterable[Mapping[str, Any]]) -> List[Participant]:
    """Build participants from raw registration rows."""

    participants: List[Participant] = []
    for row in rows:
        company = _to_text(row.get("ent_nom", "")).strip()
        # Each row can contain up to three participants, suffixed with 1..3
        for index in range(1, 4):
            last_name = _to_text(row.get(f"p{index}_nom", "")).strip()
            first_name = _to_text(row.get(f"p{index}_prenom", "")).strip()
            email = _to_text(row.get(f"p{index}_email", "")).strip()
            role = _to_text(row.get(f"p{index}_poste", "")).strip()

            if not any([last_name, first_name, email, role]):
                # Completely empty slots are ignored.
                continue

            participants.append(
                Participant(
                    company=company,
                    last_name=last_name,
                    first_name=first_name,
                    role=role,
                    email=email,
                )
            )
    return participants


def read_participants(csv_path: Path) -> List[Participant]:
    """Extract all participants from the exported CSV file."""

    with csv_path.open("r", encoding="utf-8-sig", newline="") as handle:
        reader = csv.DictReader(handle, delimiter=";")
        return extract_participants(reader)


def sanitize_filename(text: str) -> str:
    """Convert a free-form string into a filesystem friendly name."""

    if not text:
        return "participant"

    slug = re.sub(r"[^A-Za-z0-9_-]+", "-", text.strip())
    return slug.strip("-") or "participant"


def badge_basename(participant: Participant, index: int) -> str:
    """Return the base filename (without extension) for a badge."""

    identifier = sanitize_filename(
        f"{participant.last_name}_{participant.first_name}"
    )
    return f"{index:03d}_{identifier or 'participant'}"


def update_template(root: ET.Element, mapping: Dict[str, str]) -> None:
    """Update the text nodes identified by ``id`` according to ``mapping``."""

    for field, value in mapping.items():
        element = root.find(f".//*[@id='{field}']")
        if element is None:
            raise KeyError(
                f"The template does not contain an element with id '{field}'."
            )

        # SVG text elements can contain nested tspans. We update the first text
        # node so the placeholder is replaced for both cases.
        if element.text is None and len(element):
            element[0].text = value
        else:
            element.text = value


def export_badge(
    template_root: ET.Element,
    participant: Participant,
    index: int,
    output_dir: Path,
    formats: Sequence[str],
) -> List[Path]:
    """Create the badge files requested in ``formats``."""

    mapping = participant.as_mapping()
    base_name = badge_basename(participant, index)

    created_files: List[Path] = []
    svg_path = output_dir / f"{base_name}.svg"
    svg_bytes = render_badge_svg(template_root, participant)
    svg_written = False
    if "svg" in formats:
        svg_path.write_bytes(svg_bytes)
        created_files.append(svg_path)
        svg_written = True

    if any(fmt in formats for fmt in ("pdf", "png")):
        try:
            import cairosvg  # type: ignore
        except ImportError as exc:  # pragma: no cover - best effort warning
            raise SystemExit(
                "The cairosvg package is required to export PDF/PNG files. "
                "Install it with 'pip install cairosvg' or drop the pdf/png "
                "formats from the --formats argument."
            ) from exc

        # Ensure the SVG exists when exporting to other formats.
        if not svg_written:
            svg_path.write_bytes(svg_bytes)
            created_files.append(svg_path)
            svg_written = True

        if "pdf" in formats:
            pdf_path = output_dir / f"{base_name}.pdf"
            cairosvg.svg2pdf(url=str(svg_path), write_to=str(pdf_path))
            created_files.append(pdf_path)

        if "png" in formats:
            png_path = output_dir / f"{base_name}.png"
            cairosvg.svg2png(url=str(svg_path), write_to=str(png_path), dpi=300)
            created_files.append(png_path)

    return created_files


def render_badge_svg(template_root: ET.Element, participant: Participant) -> bytes:
    """Render a badge as SVG bytes for the provided participant."""

    badge_root = deepcopy(template_root)
    update_template(badge_root, participant.as_mapping())

    buffer = BytesIO()
    ET.ElementTree(badge_root).write(
        buffer, encoding="utf-8", xml_declaration=True
    )
    return buffer.getvalue()


def parse_args(argv: Sequence[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Génère des badges d'identification à partir d'un template SVG",
    )
    parser.add_argument("csv", type=Path, help="Chemin du fichier CSV exporté")
    parser.add_argument(
        "template",
        type=Path,
        help="Chemin du template SVG (par exemple static/ressources/badge_template.svg)",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=Path,
        default=Path("generated_badges"),
        help="Dossier de sortie pour les badges générés",
    )
    parser.add_argument(
        "--formats",
        "-f",
        nargs="+",
        default=["svg"],
        choices=["svg", "pdf", "png"],
        help="Formats de sortie à produire",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv or sys.argv[1:])

    if not args.csv.exists():
        raise SystemExit(f"Le fichier CSV {args.csv} est introuvable.")

    if not args.template.exists():
        raise SystemExit(f"Le template SVG {args.template} est introuvable.")

    participants = read_participants(args.csv)
    if not participants:
        raise SystemExit(
            "Aucun participant n'a été trouvé dans le fichier CSV fourni."
        )

    output_dir: Path = args.output
    output_dir.mkdir(parents=True, exist_ok=True)

    template_tree = ET.parse(args.template)
    template_root = template_tree.getroot()

    created: List[Path] = []
    for index, participant in enumerate(participants, start=1):
        created.extend(
            export_badge(
                template_root=template_root,
                participant=participant,
                index=index,
                output_dir=output_dir,
                formats=args.formats,
            )
        )

    print(f"{len(participants)} participant(s) traité(s).")
    print("Badges générés :")
    for path in created:
        print(f"  - {path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())

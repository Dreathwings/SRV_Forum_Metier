"""Generate identification badges from an SVG template.

The script reads the CSV export produced by the forum-mÃ©tier form and
creates an individual badge for each participant. Badges are generated by
duplicating the SVG template found in ``static/ressources/badge_template.svg``
and replacing the text nodes identified by their ``id`` attributes. When no
local logo is available the tool also performs a best-effort lookup via the
public Clearbit Logo service to retrieve a company logo online.

Example usage::

    python generate_badges.py dump.csv static/ressources/badge_template.svg \
        --output badges --formats svg

If ``cairosvg`` is installed you can also request PDF or PNG exports by
passing ``--formats svg pdf`` (or ``png``).
"""

from __future__ import annotations

import argparse
import base64
import csv
import json
import re
import socket
import sys
import unicodedata
import urllib.error
import urllib.parse
import urllib.request
from copy import deepcopy
from dataclasses import dataclass
from functools import lru_cache
from io import BytesIO
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping, Optional, Sequence, Tuple

import xml.etree.ElementTree as ET


# SVG documents use these namespaces. Registering them ensures that
# ElementTree keeps both the default ``svg`` namespace and the ``xlink``
# prefix used by ``image`` tags when we write the generated files.
SVG_NAMESPACE = "http://www.w3.org/2000/svg"
XLINK_NAMESPACE = "http://www.w3.org/1999/xlink"

ET.register_namespace("", SVG_NAMESPACE)
ET.register_namespace("xlink", XLINK_NAMESPACE)

BASE_DIR = Path(__file__).resolve().parent
DEFAULT_LOGO_DIRECTORIES: Sequence[Path] = (
    BASE_DIR / "static" / "ressources" / "logos",
)
GEII_LOGO_PATH = BASE_DIR / "static" / "ressources" / "geii_logo.svg"
CLEARBIT_AUTOCOMPLETE_URL = (
    "https://autocomplete.clearbit.com/v1/companies/suggest?query={query}"
)
CLEARBIT_LOGO_URL = "https://logo.clearbit.com/{domain}?size=256"
ONLINE_LOGO_TIMEOUT = 5
USER_AGENT = "forum-metier-badge-generator"
XLINK_HREF_ATTR = f"{{{XLINK_NAMESPACE}}}href"
SUPPORTED_LOGO_EXTENSIONS = (".svg", ".png", ".jpg", ".jpeg", ".webp")


@dataclass
class Participant:
    """Data structure holding the information required to build a badge."""

    company: str
    last_name: str
    first_name: str
    role: str
    email: str

    @property
    def full_name(self) -> str:
        """Return the full name formatted for display on the badge."""

        names = [self.first_name.strip(), self.last_name.strip()]
        return " ".join(part for part in names if part)

    def as_mapping(self) -> Dict[str, str]:
        """Return a mapping used to update the SVG template."""

        return {
            "company": self.company.strip() or "Entreprise",
            "full_name": self.full_name or "Participant",
            "role": self.role.strip() or "Poste",  # fallback text
            "email": self.email.strip(),
        }


def _to_text(value: Any) -> str:
    """Safely convert database/CSV values to strings."""

    if value is None:
        return ""
    return str(value)


def extract_participants(rows: Iterable[Mapping[str, Any]]) -> List[Participant]:
    """Build participants from raw registration rows."""

    participants: List[Participant] = []
    for row in rows:
        company = _to_text(row.get("ent_nom", "")).strip()
        # Each row can contain up to three participants, suffixed with 1..3
        for index in range(1, 4):
            last_name = _to_text(row.get(f"p{index}_nom", "")).strip()
            first_name = _to_text(row.get(f"p{index}_prenom", "")).strip()
            email = _to_text(row.get(f"p{index}_email", "")).strip()
            role = _to_text(row.get(f"p{index}_poste", "")).strip()

            if not any([last_name, first_name, email, role]):
                # Completely empty slots are ignored.
                continue

            participants.append(
                Participant(
                    company=company,
                    last_name=last_name,
                    first_name=first_name,
                    role=role,
                    email=email,
                )
            )
    return participants


def read_participants(csv_path: Path) -> List[Participant]:
    """Extract all participants from the exported CSV file."""

    with csv_path.open("r", encoding="utf-8-sig", newline="") as handle:
        reader = csv.DictReader(handle, delimiter=";")
        return extract_participants(reader)


def sanitize_filename(text: str) -> str:
    """Convert a free-form string into a filesystem friendly name."""

    if not text:
        return "participant"

    normalized = unicodedata.normalize("NFKD", text)
    ascii_text = normalized.encode("ascii", "ignore").decode("ascii")
    slug = re.sub(r"[^A-Za-z0-9_-]+", "-", ascii_text.strip())
    return slug.strip("-") or "participant"


def badge_basename(participant: Participant, index: int) -> str:
    """Return the base filename (without extension) for a badge."""

    identifier = sanitize_filename(
        f"{participant.last_name}_{participant.first_name}"
    )
    return f"{index:03d}_{identifier or 'participant'}"


def _iter_logo_directories(
    logo_directories: Optional[Sequence[Path]] = None,
) -> Iterable[Path]:
    """Yield the existing directories containing company logos."""

    paths: List[Path] = []
    if logo_directories:
        paths.extend(Path(path) for path in logo_directories)
    paths.extend(DEFAULT_LOGO_DIRECTORIES)

    seen: set[Path] = set()
    for directory in paths:
        resolved = directory.expanduser()
        try:
            resolved = resolved.resolve()
        except FileNotFoundError:
            # ``resolve()`` may fail on Python < 3.11 when the directory
            # does not exist. We silently ignore such entries.
            continue

        if resolved in seen:
            continue
        seen.add(resolved)

        if resolved.is_dir():
            yield resolved


def find_company_logo_path(
    company: str, logo_directories: Optional[Sequence[Path]] = None
) -> Optional[Path]:
    """Return the matching logo file for ``company`` if available."""

    slug = sanitize_filename(company).lower()
    if not slug or slug == "participant":
        return None

    for directory in _iter_logo_directories(logo_directories):
        for candidate in directory.iterdir():
            if not candidate.is_file():
                continue

            if candidate.suffix.lower() not in SUPPORTED_LOGO_EXTENSIONS:
                continue

            candidate_slug = sanitize_filename(candidate.stem).lower()
            if candidate_slug == slug:
                return candidate

    return None


@lru_cache(maxsize=None)
def _logo_data_uri(path: str) -> Optional[str]:
    """Return a data URI embedding the image found at ``path``."""

    file_path = Path(path)
    if not file_path.exists() or not file_path.is_file():
        return None

    mime_type = "image/png"
    suffix = file_path.suffix.lower()
    if suffix == ".svg":
        mime_type = "image/svg+xml"
    elif suffix in {".jpg", ".jpeg"}:
        mime_type = "image/jpeg"
    elif suffix == ".webp":
        mime_type = "image/webp"

    data = file_path.read_bytes()
    encoded = base64.b64encode(data).decode("ascii")
    return f"data:{mime_type};base64,{encoded}"


def _company_slug(text: str) -> str:
    """Return the normalized slug used to compare company names."""

    return sanitize_filename(text).lower()


def _http_request(url: str) -> Optional[bytes]:
    """Perform a small HTTP GET request and return the raw body if successful."""

    request = urllib.request.Request(url, headers={"User-Agent": USER_AGENT})
    try:
        with urllib.request.urlopen(request, timeout=ONLINE_LOGO_TIMEOUT) as response:
            if getattr(response, "status", 200) != 200:
                return None
            return response.read()
    except (urllib.error.URLError, socket.timeout):
        return None


@lru_cache(maxsize=128)
def _resolve_company_domain(company: str) -> Optional[str]:
    """Return the web domain matching ``company`` using Clearbit suggestions."""

    query = company.strip()
    slug = _company_slug(query)
    if not query or not slug or slug == "participant":
        return None

    url = CLEARBIT_AUTOCOMPLETE_URL.format(
        query=urllib.parse.quote(query, safe="")
    )
    payload = _http_request(url)
    if not payload:
        return None

    try:
        suggestions = json.loads(payload.decode("utf-8"))
    except (json.JSONDecodeError, UnicodeDecodeError):
        return None

    if not isinstance(suggestions, list):
        return None

    fallback: Optional[str] = None
    for suggestion in suggestions:
        if not isinstance(suggestion, dict):
            continue
        domain = suggestion.get("domain")
        if not domain:
            continue
        suggestion_name = suggestion.get("name", "")
        if _company_slug(str(suggestion_name)) == slug:
            return domain
        if fallback is None:
            fallback = domain
    return fallback


@lru_cache(maxsize=128)
def _download_logo_from_domain(domain: str) -> Optional[Tuple[bytes, str]]:
    """Download the logo for ``domain`` via Clearbit and return its content."""

    url = CLEARBIT_LOGO_URL.format(domain=urllib.parse.quote(domain, safe=""))
    request = urllib.request.Request(url, headers={"User-Agent": USER_AGENT})
    try:
        with urllib.request.urlopen(request, timeout=ONLINE_LOGO_TIMEOUT) as response:
            if getattr(response, "status", 200) != 200:
                return None
            data = response.read()
            content_type = response.info().get_content_type()
    except (urllib.error.URLError, socket.timeout):
        return None

    if not data:
        return None

    if not content_type or not content_type.startswith("image/"):
        content_type = "image/png"
    return data, content_type


def _online_logo_data_uri(company: str) -> Optional[str]:
    """Try to locate a company logo on the internet and return it as a data URI."""

    slug = _company_slug(company)
    if not slug or slug == "participant":
        return None

    domain = _resolve_company_domain(company)
    if not domain:
        return None

    download = _download_logo_from_domain(domain)
    if not download:
        return None

    data, mime_type = download
    encoded = base64.b64encode(data).decode("ascii")
    return f"data:{mime_type};base64,{encoded}"


def _set_image_href(element: ET.Element, href: Optional[str]) -> None:
    """Update the ``href``/``xlink:href`` attributes of an ``image`` tag."""

    if href:
        element.set("href", href)
        element.set(XLINK_HREF_ATTR, href)
        element.set("visibility", "visible")
    else:
        element.attrib.pop("href", None)
        element.attrib.pop(XLINK_HREF_ATTR, None)
        element.set("visibility", "hidden")


def _apply_geii_logo(root: ET.Element) -> None:
    """Ensure the GEII department logo is present on the badge."""

    element = root.find(".//*[@id='logo_geii']")
    if element is None:
        return

    href = _logo_data_uri(str(GEII_LOGO_PATH))
    _set_image_href(element, href)


def _apply_company_logo(
    root: ET.Element,
    company: str,
    logo_directories: Optional[Sequence[Path]] = None,
    allow_online_logo_lookup: bool = True,
) -> None:
    """Attach the logo of ``company`` to the badge when available."""

    element = root.find(".//*[@id='company_logo']")
    if element is None:
        return

    logo_path = find_company_logo_path(company, logo_directories)
    href = _logo_data_uri(str(logo_path)) if logo_path else None
    if not href and allow_online_logo_lookup:
        href = _online_logo_data_uri(company)
    _set_image_href(element, href)


def update_template(root: ET.Element, mapping: Dict[str, str]) -> None:
    """Update the text nodes identified by ``id`` according to ``mapping``."""

    for field, value in mapping.items():
        element = root.find(f".//*[@id='{field}']")
        if element is None:
            raise KeyError(
                f"The template does not contain an element with id '{field}'."
            )

        # SVG text elements can contain nested tspans. We update the first text
        # node so the placeholder is replaced for both cases.
        if element.text is None and len(element):
            element[0].text = value
        else:
            element.text = value


def export_badge(
    template_root: ET.Element,
    participant: Participant,
    index: int,
    output_dir: Path,
    formats: Sequence[str],
    logo_directories: Optional[Sequence[Path]] = None,
    allow_online_logo_lookup: bool = True,
) -> List[Path]:
    """Create the badge files requested in ``formats``."""

    mapping = participant.as_mapping()
    base_name = badge_basename(participant, index)

    created_files: List[Path] = []
    svg_path = output_dir / f"{base_name}.svg"
    svg_bytes = render_badge_svg(
        template_root,
        participant,
        logo_directories=logo_directories,
        allow_online_logo_lookup=allow_online_logo_lookup,
    )
    svg_written = False
    if "svg" in formats:
        svg_path.write_bytes(svg_bytes)
        created_files.append(svg_path)
        svg_written = True

    if any(fmt in formats for fmt in ("pdf", "png")):
        try:
            import cairosvg  # type: ignore
        except ImportError as exc:  # pragma: no cover - best effort warning
            raise SystemExit(
                "The cairosvg package is required to export PDF/PNG files. "
                "Install it with 'pip install cairosvg' or drop the pdf/png "
                "formats from the --formats argument."
            ) from exc

        # Ensure the SVG exists when exporting to other formats.
        if not svg_written:
            svg_path.write_bytes(svg_bytes)
            created_files.append(svg_path)
            svg_written = True

        if "pdf" in formats:
            pdf_path = output_dir / f"{base_name}.pdf"
            cairosvg.svg2pdf(url=str(svg_path), write_to=str(pdf_path))
            created_files.append(pdf_path)

        if "png" in formats:
            png_path = output_dir / f"{base_name}.png"
            cairosvg.svg2png(url=str(svg_path), write_to=str(png_path), dpi=300)
            created_files.append(png_path)

    return created_files


def render_badge_svg(
    template_root: ET.Element,
    participant: Participant,
    logo_directories: Optional[Sequence[Path]] = None,
    allow_online_logo_lookup: bool = True,
) -> bytes:
    """Render a badge as SVG bytes for the provided participant."""

    badge_root = deepcopy(template_root)
    update_template(badge_root, participant.as_mapping())
    _apply_geii_logo(badge_root)
    _apply_company_logo(
        badge_root,
        participant.company,
        logo_directories=logo_directories,
        allow_online_logo_lookup=allow_online_logo_lookup,
    )

    buffer = BytesIO()
    ET.ElementTree(badge_root).write(
        buffer, encoding="utf-8", xml_declaration=True
    )
    return buffer.getvalue()


def parse_args(argv: Sequence[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="GÃ©nÃ¨re des badges d'identification Ã  partir d'un template SVG",
    )
    parser.add_argument("csv", type=Path, help="Chemin du fichier CSV exportÃ©")
    parser.add_argument(
        "template",
        type=Path,
        help="Chemin du template SVG (par exemple static/ressources/badge_template.svg)",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=Path,
        default=Path("generated_badges"),
        help="Dossier de sortie pour les badges gÃ©nÃ©rÃ©s",
    )
    parser.add_argument(
        "--formats",
        "-f",
        nargs="+",
        default=["svg"],
        choices=["svg", "pdf", "png"],
        help="Formats de sortie Ã  produire",
    )
    parser.add_argument(
        "--logo-dirs",
        metavar="PATH",
        type=Path,
        nargs="+",
        default=None,
        help=(
            "Dossiers supplÃ©mentaires contenant les logos d'entreprise. "
            "Les fichiers doivent Ãªtre nommÃ©s d'aprÃ¨s le nom de l'entreprise"
            " (ex. sanitisation: Nom_Entreprise.png)."
        ),
    )
    parser.add_argument(
        "--no-online-logos",
        action="store_true",
        help=(
            "DÃ©sactive la recherche automatique de logos en ligne via Clearbit."
        ),
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv or sys.argv[1:])

    if not args.csv.exists():
        raise SystemExit(f"Le fichier CSV {args.csv} est introuvable.")

    if not args.template.exists():
        raise SystemExit(f"Le template SVG {args.template} est introuvable.")

    participants = read_participants(args.csv)
    if not participants:
        raise SystemExit(
            "Aucun participant n'a Ã©tÃ© trouvÃ© dans le fichier CSV fourni."
        )

    output_dir: Path = args.output
    output_dir.mkdir(parents=True, exist_ok=True)

    template_tree = ET.parse(args.template)
    template_root = template_tree.getroot()

    logo_directories: Optional[Sequence[Path]] = args.logo_dirs

    created: List[Path] = []
    for index, participant in enumerate(participants, start=1):
        created.extend(
            export_badge(
                template_root=template_root,
                participant=participant,
                index=index,
                output_dir=output_dir,
                formats=args.formats,
                logo_directories=logo_directories,
                allow_online_logo_lookup=not args.no_online_logos,
            )
        )

    print(f"{len(participants)} participant(s) traitÃ©(s).")
    print("Badges gÃ©nÃ©rÃ©s :")
    for path in created:
        print(f"  - {path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
